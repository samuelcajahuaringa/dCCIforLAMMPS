#
units             metal
boundary          p p p
atom_style        atomic

lattice           diamond  ${a0}

region            box block 0 10 0 10 0 10
create_box        1   box
create_atoms      1   box


pair_style        sw
pair_coeff        * * Si.sw Si
mass              1   ${m}

neighbor          1.0 bin
neigh_modify delay 0 

min_style cg
minimize 1e-25 1e-20 10000 10000

timestep          ${dt}
 
reset_timestep    0

#----------------------- Fixes, computes, & constrains ------------------------#
# Compute temperature using center-of-mass coordinates.
compute           c1 all temp/com

# Thermostat and Frenkel-Ladd fix.
fix               f1 all nve
fix               f2 all ti/spring ${k} ${t_sw} ${t_eq} function ${func}
fix               f3 all langevin $T $T ${Tdamp} ${seed} zero yes
fix_modify        f3 temp c1
#------------------------------------------------------------------------------#

#------------------------ Simulation & output setup ---------------------------#
# Setup output varibles
variable          step    equal step
variable          dU      equal pe-f_f2
variable          lambda  equal f_f2[1]

# Redefine simulation time to capture first and last steps on output files.
# Notice that this does not affect the switching time.
variable         t_eq_run equal ${t_eq}-1
variable         t_sw_run equal ${t_sw}+1

# Thermo output.
thermo_style  custom step pe v_dU
thermo_modify flush yes
thermo        0
#------------------------------------------------------------------------------#

#------------------------- Running simulation ---------------------------------#
# Initial temperature to accelerate equilibration.
variable         rnd equal round(random(0,999,${seed}))
variable         T0 equal 2*${T}
velocity         all create ${T0} ${rnd} mom yes rot yes dist gaussian

# Forward integration.
run              ${t_eq_run}
fix              f4 all print 1 "${dU} ${lambda}" screen no title "#dU [eV] lambda" & 
                 file t_switch${t_sw}/forward_${T}K_${N_sim}.dat 
run              ${t_sw_run}
unfix            f4

# Backward integration. 
run              ${t_eq_run}
fix              f4 all print 1 "${dU} ${lambda}" screen no title "#dU [eV] lambda" &
                 file t_switch${t_sw}/backward_${T}K_${N_sim}.dat 
run              ${t_sw_run}
unfix            f1
unfix            f2
unfix            f3
unfix            f4
